### 设计
在这个文档中，我们首先在顶层设计上描述这个系统。然后，我们再引入约束和不变量来确定问题域。我们会一步步地提出一个具体的解决方案，描述框架中的关键组件和组件之间的行为。

#### 生产者与消费者
我们有一个大且动态地生产者集，它们会生产大量的日志记录流。这些记录应该可供消费者查找到的。

```golang
     +-----------+
P -> |           |
P -> |     ?     | -> C
P -> |           |
     +-----------+
```

生产者主要关心日志被消费的速度尽可能地快。如果这个速度没有控制好，有一些策略可以提供，包括：[背压策略](http://www.jianshu.com/p/2c4799fa91a4)(ps: 流速控制), 例如：事件日志、缓冲和数据丢弃(例如：应用程序日志)。在这些情况下，接收日志记录流的组件需要优化顺序写操作。

消费者主要关心尽快地响应用户端的日志查询，保证尽可能快的日志持久化。因为我们定义了查询必须带时间边界条件，我们要确保我们可以通过时间分隔数据文件，来解决`grep`问题。所以存储在磁盘上的最终数据格式，应该是一个按照时间划分的数据文件格式，且这些文件内的数据是由所有生产者的日志记录流全局归并得到的。如下图所示：

```golang
     +-------------------+
P -> | R                 |
P -> | R     ?     R R R | -> C
P -> | R                 |
     +-------------------+
```

#### 设计细节
我们有上千个有序的生产者。(一个生产者是由一个应用进程，和一个forward代理构成)。我们的日志系统有必要比要服务的生产系统小得多。因此我们会有多个ingest节点，每个ingest节点需要处理来自多个生产者的写请求。

我们也想要服务于有大量日志产生的生产系统。因此，我们不会对数据量做还原性假设。我们假设即使是最小工作集的日志数据，对单个节点的存储可能也是太大的。因此，消费者将必须通过查询多个节点获取结果。这意味着最终的时间分区的数据集将是分布式的，并且是复制的。

producers --> forwarders --> ingester ---> **storage** <--- querying  <--- consumer

```golang
          +---+           +---+
P -> F -> | I |           | Q | --.
P -> F -> |   |           +---+   |
          +---+           +---+   '->
          +---+     ?     | Q | ----> C
P -> F -> | I |           +---+   .->
P -> F -> |   |           +---+   |
P -> F -> |   |           | Q | --'
          +---+           +---+
```

现在我们引入分布式，这意味着我们必须解决协同问题。


